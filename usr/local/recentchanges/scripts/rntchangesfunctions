#!/usr/bin/env bash
#   Developer buddy 5.0 core                                               02/25/2026

# ascii positional encoding
# escape input newlines for parsing
ap_safeline() {
local o="$1"
o="${o//\\/\\ap5c}" ; o="${o//$'\n'/\\ap0A}" ; printf '%s' "$o"
}
ap_safeline_dec() {
local k="$1"
k="${k//\\ap0A/$'\n'}" ; k="${k//\\ap5c/\\}" ; printf '%s' "$k"
}

# Escape existing if filename has \ap5c, \ap22, \ap0A in actual input. then completly encode
ap_enc() {
local o="$1"
o="${o//\\/\\ap5c}" ; o="${o//$'\n'/\\ap0A}"  ; o="${o//\"/\\ap22}" ; o="${o//$'\t'/\\ap09}" ; o="${o// /\\ap20}"  
printf '%s' "$o"
}
# decrypt for file operations
ap_dec() {
local k="$1"
k="${k//\\ap0A/$'\n'}" ; k="${k//\\ap09/$'\t'}" ; k="${k//\\ap22/\"}" ; k="${k//\\ap20/\ }" ; k="${k//\\ap5c/\\}"
printf '%s' "$k"
}
# final file output same as above but leaves newlines escaped
ap_filedec() {
local k="$1"
k="${k//\\ap0A/$'\\n'}" ; k="${k//\\ap09/$'\t'}" ; k="${k//\\ap22/\"}" ; k="${k//\\ap20/\ }" ; k="${k//\\ap5c/\\}"
printf '%s' "$k"
}

# used for file output
escf() {
local o="$1" 
o="${o//\\/\\ap5c}"
# o="${o//\\/\\\\}"
o="${o//$'\n'/\\\\n}"
# o="${o//\"/\\\"}"
# o="${o//$/\\\$}"
# o="${o//$'\t'/\\t}"
printf '%s' "$o"
}
unescf() {
local k="$1"
k="${k//\\\\n/$'\n'}"
k="${k//\\ap5c/\\}"
#k="${k//\\\"/\"}"
#k="${k//\\\\/\\}" 
#  k="${k//\\\$/\$}"
# k="${k//\\t/$'\t'}"
printf '%s' "$k"
}

generatekey() {
	# 5.1 porteus   GPG 2.x+ generate key but if 5.01 has GPG2 do it too

	xopt=$(mktemp -d /tmp/tmpda.XXXXXX)
	# if command -v gpg2 >/dev/null 2>&1 || gpg --version | grep -qiE "gnupg.*2|\(GnuPG\) 2"; then
	if which gpg2 > /dev/null 2>&1 || gpg --version | grep -qiE "gnupg.*2|\(GnuPG\) 2" ; then
		read -sp "Enter passphrase for new GPG key: " p
cat > $xopt/keyparams.conf <<EOF
%echo Generating a GPG key
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: $name
Name-Email: $email
Expire-Date: 0
Passphrase: $p
%commit
%echo done
EOF
		if which gpg2 > /dev/null 2>&1; then
			cmd=(gpg2)
			"${cmd[@]}" --batch --pinentry-mode loopback --passphrase "$p" --generate-key $xopt/keyparams.conf
		else
			cmd=(gpg)
			"${cmd[@]}" --batch --pinentry-mode loopback --passphrase "$p" --generate-key $xopt/keyparams.conf
		fi
		shred -u $xopt/keyparams.conf
		if [[ "$USR" != "root" ]]; then
            echo "Please enter password for root"
			printf '%s' "$p" | "${cmd[@]}"  --batch --yes --pinentry-mode loopback --passphrase-fd 0 --export-secret-keys --armor $email > $xopt/key.asc
			printf '%s' "$p" | sudo "${cmd[@]}"  --batch --yes --pinentry-mode loopback --passphrase-fd 0 --import $xopt/key.asc
			shred -u $xopt/key.asc
			printf "trust\n5\ny\nquit\n" | sudo "${cmd[@]}"  --command-fd 0 --edit-key $email
		fi
		test -d "$xopt" && rm -rf "$xopt"
		echo "GPG key generated for ${email}."
	else
		if ! gpg --with-keygrip --list-secret-keys >/dev/null 2>&1; then
			echo "Gpg 1.4 or outdated version installed please install gpg2. recommended."
			if which expect > /dev/null 2>&1; then # is expect installed?
				echo "Use expect. And run the keygen file for 5.01. Remember to remove passphrase after from file."
			else
				echo "Expect not installed."
			fi
			echo
			echo "If using gpg 1.4 a key can be made by installing expect and running the keygen file. Then erase the passphrase you entered in the file from the file."
			echo "In order for it to work with this script the keypair then has to be exported to root with:"
			echo "gpg --export-secret-keys --armor email > key.asc"
			echo "then sudo su and  as root"
			echo  "gpg --import key.asc"
			echo " gpg --edit-key email  . then set  True, 5, y, quit to trust the key"
		fi
		exit 1
	fi
}

setup_exports() {
	output=$( python3 "$app_install"/get_exports.py $USR) ; res=$?
	if [[ $res -ne 0 ]]; then echo "Couldnt get config file config.toml" && exit 1 ; fi
	eval "$output"
	if ! gpg --list-keys | grep -q $email; then generatekey ; fi  # setup key pair for both user and root
}

display() {
local locale=$1
if [[ -n "$locale" && "$dspEDITOR" != "false" ]]; then
    if [[ -n "$dspPATH" ]]; then [[ ! -e "$dspPATH" ]] && { echo "dspPATH setting invalid - ${dspPATH} not found" >&2 ; return 1 ; } ; "$dspPATH" "$locale" && return ; echo "Error: Failed to open ${locale} with ${dspPATH}" >&2 ; return 1 ; fi
	[[ -n "$dspEDITOR" && "$dspEDITOR" != "xed" && "$dspEDITOR" != "featherpad" ]] && echo "$dspEDITOR chosen if using other editor please specify dspPATH" && return 1 || { [[ -z "$dspEDITOR" ]] && return 1 ; }
	editor_path=$( which $dspEDITOR 2> /dev/null)
	if [[ -n "$editor_path" ]]; then
		test -e $editor_path && "$editor_path" "$locale" && return || { ! test -e "$editor_path" && echo couldnt launch $dspEDITOR at "$editor_path" ; }
	else
		test -e /usr/bin/$dspEDITOR && /usr/bin/$dspEDITOR "$locale" && return  || { ! test -e /usr/bin/$dspEDITOR && echo couldnt find $dspEDITOR in path or in default /usr/bin please specify dspPATH: "$tomlf" ; }
	fi
	return 1
fi
}

# load text editor if user want to display as non root
output_results() {
	local file_out="$XDG_RUNTIME_DIR"/file_output
	if [[ $res -eq 0 ]]; then test -f $file_out && var=$( cat $file_out) && display "$var" ; test -f $file_out && rm $file_out ; fi
	exit $res
}

upt_cache() {
local inode=$1
local size=$2
local mtime=$3
local checksum=$4
local path="$5"
local cache_file=$6
printf '%s|%s|%s\t%s\t%s\n' "$inode" "$size" "$mtime" "$checksum" "$path" >> "$cache_file"
}

get_cached() {
local inode=$1
local size=$2
local mtime=$3
local key="$inode|$size|$mtime"
grep -m1 "^${key}	" "$CACHE_F" | awk -F $'\t' '{print $2}'
}
# [[:space:]]
normalize_ts() { printf "%.6f\n" "$1" ; }

# [[ "$t" == *.* ]] && frac="${t#*.}"
normalize_frac() {
  local frac="$1"
  frac="${frac}000000"
  printf '%d\n' "${frac:0:6}"
}

calculate_csum() {
local xmode="$1"				;	local file_path="$2"
local modified_epoch=$3	;	local ino=$4
local sze=$5
local x=$6
local delay=$7
local debug_log=$8
local debug_file=$9
local log_date=${10}
# globals from sblk are csum mtime itime mt ct fs i sym n onr grp pmr
local ctime_epoch
local f1 f2 f3 f4 a_ino a_sym a_nlnk a_sze a_onr a_grp a_prm
local mod_time change_time
local c r
local checks
local prev_hash=""
local max_retries=0

if [ "$ino" -ge 0 ] 2>/dev/null && [ "$sze" -ge 0 ] 2>/dev/null; then
	while (( x >= 0 )); do
		r=""
	    checks=$( md5sum "$file_path" 2>/dev/null)
		if [[ -n "$checks" ]]; then
			checks=${checks%% *}
			# on second or later iteration and not ctime as ctime could no longer be > mtime now
			if [[ -n "$prev_hash" &&"$checks" = "$prev_hash" ]]; then

				if [ "$a_ino" -ge 0 ] 2>/dev/null; then
					# update only needed stats
					check_sum=$checks
					mtime=$modified_epoch
                    itime=$ctime_epoch
                    mtime_sec=${mtime%%.*}
                    itime_sec=${itime%%.*}
					mtime_frac=${mtime#*.}
					mt=$(date -d "@$mtime_sec" +"$fmt")
                    ct=$(date -d "@$itime_sec" +"$fmt" 2> /dev/null)
					fs=$a_sze
					# the inode changed update all remaining stats
					if (( ino != a_ino )); then
						i=$a_ino
						sym=$a_sym
						n=$a_nlnk
						onr=$a_onr
						grp=$a_grp
						pmr=$a_prm
					fi
					return 0
				fi

			fi
			if (( x > 0 )); then
				read -r f1 f2 _ f3 f4 _ a_ino a_sym a_nlnk a_sze a_onr a_grp a_prm < <( stat --format="%y %z %i %A %h %s %U %G %a" "$file_path" 2>/dev/null)  # %A
				[[ -z "$a_prm" ]] && break
				mod_time="$f1 $f2"
				c=$( date -d "$mod_time" +%s.%N 2>/dev/null)  # %6N
				[[ -z "$c" ]] && log_lineout $debug_log $debug_file "$log_date" "calculate checksum failed to convert timestamp retry $(( max_retries - x ))" && return 1  # mtime required
                c=$(normalize_ts "$c")

				# if it matches the find command or if two stats match return the checksum
				if [[ "$c" == "$modified_epoch" && -n "$a_ino" && -n "$a_sze" ]] && (( ino == a_ino )) && (( sze == a_sze )); then
					check_sum=$checks
					if [[ -z "$prev_hash" ]]; then
						return 0
					else
						mtime=$modified_epoch
		                itime=$ctime_epoch
			            mtime_sec=${mtime%%.*}
			            itime_sec=${itime%%.*}
						mtime_frac=${mtime#*.}
						mt=$(date -d "@$mtime_sec" +"$fmt")
		                ct=$(date -d "@$itime_sec" +"$fmt" 2> /dev/null)
						return 0
					fi
				fi

	    		# else retry
				modified_epoch=$c
				change_time="$f3 $f4"
                r=$( date -d "$change_time" +%s.%N 2>/dev/null)
				[[ -n "$r" ]] && r=$(normalize_ts "$r") || log_lineout $debug_log $debug_file "$log_date" "calculate_csum Warning ct is null on retried. retry $(( max_retries - x ))" && return 1
				ctime_epoch=$r
				prev_hash="$checks"
                sleep $delay
			fi
		else
			break
		fi
	    (( x-- ))
	done
fi
log_lineout $debug_log $debug_file "$log_date" "calculate_csum failed no checksum skipping. retry $(( max_retries - x ))"
return 1
}


log_lineout() { [[ "$1" = "true" ]] && echo "$3 $4" >> $2 ; }

# Inotifyloop variant of sblk design to get the checksum and verify ctime greater than mtime afterwards. althrough its ctime it passed main as xmode to calculate_checksum
# Adding any sort of delays is for small scale so it is set to 0. max would be .5 seconds. Situation if 10000 files were created times that by delays and its bad.
# Could do parallel processing with xargs in inotify.sh would fix that and a delay of 2 seconds would be good.
# If the threshold is high better to implement CREATED even filepath to array then on CLOSE_WRITE check this array and hash. This
# can be implemented in python as bash its too complicated. do cache files over 1MB.
pblk() {
local debug_log="$7"
local debug_file="$8"
local fmt="%Y-%m-%d %H:%M:%S"
local r y z
local mod_time mtime_us csum_rlt
local cam sl lmt cFILE retries
local log_date
local cache_flg="false"
local cdir="/tmp/dbctimecache/"

r=""				;	sl=""
lmt=""			;	nlinks=""
cam="None"
check_sum=""

[[ "$7" = "true" ]] && log_date="$(date +"$fmt")"

cur_line="$( ap_safeline "$1")"
log_lineout $7 $8 "$log_date" "pblk line in $cur_line"  # debug
read -r mtime atime itime i sym n fs onr grp pmr cFILE <<< "$cur_line"
log_lineout $7 $8 "$log_date" "itime: $itime and mtime: $mtime , pblk after parsing line in $cur_line"

cFILE="$( ap_safeline_dec "$cFILE")"
y="$( ap_enc "$cFILE")"

mtime_sec=${mtime%%.*}
itime_sec=${itime%%.*}
mt=$(date -d "@$mtime_sec" +"$fmt")
ct=$(date -d "@$itime_sec" +"$fmt")
if [ -e "$cFILE" ] && [ -f "$cFILE" ]; then
    if [ -n "$mt" ]; then
		[[ -z "$ct" ]] && log_lineout $7 $8 "$log_date" "Warning ct is null on input to pblk $1" && return 1
		mtime=$( normalize_ts "$mtime")
		itime=$(normalize_ts "$itime")
		mtime_frac=${mtime#*.}

	    if [ "$4" == "true" ]; then
			[[ "$sym" == l* ]] && sl="y" && check_sum="None"
			if [[ -z "$sl" ]]; then
				[[ -e "$CACHE_F" ]] && mtime_us=$(( $mtime_sec * 1000000 + (10#$mtime_frac) )) && r=$(get_cached $i $fs $mtime_us)
		        if [[ -n "$r" ]]; then
		            check_sum="$r"
		        else
					calculate_csum "main" "$cFILE" $mtime $i $fs 2 0 $debug_log $debug_file $log_date
					csum_rlt=$?
					(( csum_rlt == 0 )) || return 1
		            cache_flg="true"
		        fi
			fi
            if [[ -n "$check_sum" ]]; then

                fs=${fs:-None} ; sl=${sl:-None}
                wnr=${onr:-None} ; grp=${grp:-None} ; pmn=${pmr:-None}
                adtcmd="$check_sum $fs $sl $wnr $grp $pmn"
                nlinks=$n
                ats=$(date -d "@${atime%%.*}" +"$fmt")

				ct=${ct:-None None}
                ats=${ats:-None None}
                lmt=${lmt:-None None}

                [[ "$7" = "true" ]] && log_date="$(date +"$fmt")"

                if [[ -n "$ct" && "$5" = "ctime" ]]; then

                    # change_t=$(echo "scale=0; $itime * 100000000 / 1" | bc)
                    # itime_frac=$(( change_t % 100000000 ))
                    itime_frac=${itime#*.}
					itime_oct=$(( 10#$itime_frac ))
					mtime_oct=$(( 10#$mtime_frac ))
					mtime_us=$(( mtime_sec * 1000000 + mtime_oct))

                    if (( itime_sec == mtime_sec && itime_oct > mtime_oct )) || (( itime_sec > mtime_sec )); then   # awk -v it="$itime" -v mt="$mtime" 'BEGIN {exit !(it > mt)}'; then

                        log_lineout $7 $8 "$log_date" "change time: $itime and mtime: $mtime , pblk passed processed line in $cur_line"

                        cam="y" ; lmt=$mt ; mt=$ct

                        output="$mt \"$y\" $ct $i $ats $adtcmd $cam $lmt $nlinks $mtime_us"

                        if [[ "$cache_flg" = "true" ]] && (( fs > 1000000 )); then [[ -d $cdir ]] || mkdir -p $cdir ; z="$( escf "$cFILE")" ; upt_cache "$i" "$fs" "$mtime_us" "$check_sum" "$z" "$6" ; fi

                        printf '%s\n' "$output" >> $2

                    else
                        log_lineout $7 $8 "$log_date" "pblk failed to process. itime $itime and mtime $mtime ctime was <= mtime skipped. line $1"
                        output="$mt \"$y\" $ct $i $ats $adtcmd $cam $lmt $nlinks $mtime_us"
                        log_lineout $7 $8 "$log_date" "pblk results $output"
                    fi
                else
                    [[ "$5" != "ctime" ]] && log_lineout $7 $8 "$log_date" "ctime is not set. currently set to $5 continue $1"
                    output="$mt \"$y\" $ct $i $ats $adtcmd $cam $lmt $nlinks $mtime_us"
                    log_lineout $7 $8 "$log_date" "pblk results $output"
                fi
            else
                log_lineout $7 $8 "$log_date" "pblk no checksum skipping $1"
            fi
        else
            log_lineout $7 $8 "$log_date" "pblk checksum is false skipping $1"
	    fi
    else
        log_lineout $7 $8 "$log_date" "Warning mt is null on input to pblk skipped $1"
    fi
else
    log_lineout $7 $8 "$log_date" "change time: $itime and mtime: $mtime , sblk Nosuchfile line $cur_line"
fi
}
